Warning: This document is practically a stream-of-consciousness, and
several parts are out-of-date. It contains many errors, false-starts,
and dead ends.

## Protecting the master secret ##

Protecting the master secret requires special care because compromise
of the master secret leads to the compromise of all derived secrets.

Use of a secret-sharing protocol, like Shamir's scheme, is highly
recommended.

Here I will describe a mechanism that uses Shamir's scheme to protect
the master secret and uses secure elements to protect the master
secret and derived secrets at every stage.

The idea is that we break up the master key into `n` slices, of which
`k` are required to be able to reconstruct the secret. These slices
may be stored on USB drives, smart cards, or even paper.

Care must be taken to ensure that the machine which is used
to combine the slices to generate new derived keys from the master
secret is not compromised, but if the master secret is not marked as
exportable then it a compromised machine will only have access to
the derived secrets.

To derive a secret, you collect the secure elements and pick one to be
the "master". The master then communicates with the other secure
elements, mutually authenticates, and then exchanges the secret
slices. Once `k` slices have been obtained by the master, it can then
be used to derive new keys. Under no circumstances does the master
secret ever leave the secure element.

Mutual authentication is achieved using Blom's scheme, which is the
algorithm used by HDCP copy protection. This mechanism is secure to
use in this circumstance as long the value of `k_blom` is greater than
or equal to `k_shamir`. In practice, there is little reason for these
values to not be exactly equal.

This mechanism provides for both mutual authentication and encryption
between provisioned devices, without relying on asymmetric-key
cryptography.

The specific implementation of shamir secret sharing is identical to
that used for `libgfshare`, except that the polynomial coefficients
are calculated deterministically using DSID `internal:shamir?v=V`,
where `V` is the current "protection version" (described below).

If some shares are compromised, the remaining shares can be collected
and re-calculated to make the compromised shares useless. This is done
by incrementing the "protection version" and re-commissioning all
cards.

This is how the mechanism works.

The secure element has the following methods:

 *  `Reconstruct_Challenge(Data)` - Returns `Challenge`
 *  `Reconstruct_Respond(Challenge)` - Returns `EncryptedResponse`
 *  `DeriveKey(DSID, MOD)` - returns a random number identified by DSID
    that is less than or equal to MOD.
 *  `GetStatus()` - Returns (`SlicesNeeded`, `SlicesObtained`,
    `SlicesContained`, `SliceIDsOfContainedSlices`)
 *  `Initialize(n, k, entropy)` - Initialize a new master secret, mixing
    `entropy` with additional entropy generated by the internal TRNG;
    with a maximum of `n` issued shares, and `k` shares needed to
    reconstruct the key.
 *  `Provision(n)` - Generate provisioning info for a secure element
    with `n` shares.
 *  `Inject(ProvisionData)` - Initialize app with the given provisioning
    data.

`Reconstruct_Challenge()` is initially called with an empty parameter.
The resulting data is then passed to `Reconstruct_Respond()`. The
resulting data is then in turn passed back to
`Reconstruct_Challenge()`. This back-and-forth is continued until an
error is generated or the exchange has completed (indicated by a
successful return code).

Once enough slices are obtained, the master secret will become
unlocked and new secrets may be derived. Once the secure element is
reset, it will once again become locked.

IMPORTANT: Due to physical limitations in the design of some secure
elements, it may not be possible during reconstruction to store all of
the slices from other secure elements in non-volatile RAM. In such a
case, it is imperative that the application be reset and re-selected
before disconnecting the secure element. Failure to do so could render
the master secret recoverable by a dedicated adversary with physical
access to the secure element.

Any secure element in the group may be used to reconstruct the master
secret (with the help of other secure elements)

The matrix generated for Blom's scheme shall use secrets generated
from the master secret, using the following DSID
`internal:blom?v=V;i=I;j=J`, where `I` and `J` are decimal indexes of
the matrix and `V` is the protection version. MOD is set to the same
`p` as NIST curve P-256: `2^256 - 2^224 + 2^192 + 2^96 - 1`. The
entire matrix need not be stored in memory, but may be used as needed.

Note that any DSID that is prefixed with `internal:` is only allowed
to be calculated internally within the secure element. Any attempts to
fetch the value associated with such a DSID from an external interface
MUST fail.

When a new card is being provisioned, a new public/private Blom
key-pair is generated, along with `n` slices. This data is optionally
asymmetrically encrypted for import into the card being provisioned.

The following information is included with each "slice":

 *  Slice number. 8-bit.
 *  Slice data. Size of master key.
 *  CRC or other hash, verifying that the key isn't corrupted.

When a card is regenerating the master secret, it performs mutual
authentication with each card before slice data is exchanged. This
process is stateful on both sides. The process looks like this:

### Recombination ###

We have two cards: "Master" and "Slave".

 *  Master generates the "initial challenge", which contains the
    public key and a randomly-generated `ChallengeM`.
 *  The Slave uses Master's public key to generate the shared key
    using Blom's scheme. This value is hashed using HMAC-SHA256 using
    the challenge as the key and the shared key as the message. This
    value is then used to encrypt `ChallengeM`. The "initial response"
    contains the public key of the slaveand the encrypted
    `ChallengeS`.
 *  The master

### Proposed parameters ##

 *  `n` (Number of shares) = 7
 *  `k` (Shares needed) = 4
 *  `p_blom` = `2^256 - 2^224 + 2^192 + 2^96 - 1` (256-bits)
 *  `mslen` = 256 bits (32 bytes)
 *  `HMAC` = HMAC-SHA256
 *  `hlen` = 256

### References ##

 * [Blom's Scheme](https://en.wikipedia.org/wiki/Blom%27s_scheme)

---


### RSA Key Generation ###

To calculate an RSA key of nlen size, generate a random value with an
empty salt that is twice the size as nlen.

`p` and `q` are derived from the most and least (respectively)
significant halves of the random value, and refined using the
following algorithm:

    p_len = floor(nlen/2)
    q_len = (nlen-plen)

1.  Set the two most significant bits and the least significant bit.
2.  If the number is not prime, goto 1.
3.  ???
4.  PR0FIT!!1

65537 is always assumed to be the public exponent.

Consider an option for using Lim and Lee algorithm.

Alternatives:

 *  FIPS 18.6 Appendix B.3.2.2
 *  Versile Platform 0.8.1-DRAFT 14.2.2 Identity Generation

---

Methods to deterministically calculate the following types of data
from the master secret are/will-be defined:

 *  StringOfBytes
 *  IntegerLessThanX
 *  Large Prime Number
     *  PrimeNormal
     *  PrimeSafe
     *  PrimeStrong
     *  PrimeLeeLim
 *  RSAPrivateKey
 *  DSAParameters
 *  ECPrivateKey

There are also the following derived types:

 *  EC256PPublicKey (Uses IntegerLessThanX)
 *  EC256K1PublicKey (Uses IntegerLessThanX)
 *  BitcoinAddress (Uses ECC256K1PublicKey)
 *  RSAPublicKey (Uses RSAPrivateKey)

When requesting each class of random value, you specify a key
identifier and salt. The key identifier and salt are compressed using
HMAC-SHA256 into a 256-bit key selector:

    KeySelector = HMAC_SHA256(Salt, KeyIdentifierString)

Ultimately, every class of random value ultimately uses the
StringOfBytes class recursively to extract random values from the
master secret. Each class generally permutes the key selector before
processing it.

StringOfBytes permutes as follows:

    NewKeySelector = HMAC_SHA256(GivenKeySelector, BigEndian32(KeyLength in octets))

IntergerLessThanX will pass the given key selector along to
StringOfBytes directly on the first attempt. If the attempt fails (the
calculated value was too large), the key selector is permuted using
`HMAC-SHA256(KeySelector, attemptcount)` and another attempt is made.
This continues until a satisfactory number is calculated.

The prime classes, as well as the ECPrivateKey class, always permute
the key selector with the name of the class before calling into
subclasses:

    NewKeySelector = HMAC_SHA256(GivenKeySelector, "NormalPrime"|BigEndian32(Prime length in octets))

The RSA class permutes the key selector to generate different keys for
P and Q:

    NewKeySelector_P = HMAC_SHA256(GivenKeySelector, "RSAPrivateKey:p")
    NewKeySelector_Q = HMAC_SHA256(GivenKeySelector, "RSAPrivateKey:q")

Calculating DSAParameters uses a similar construct.

The actual key identifier is an arbitrary string of bytes. While it
could be anything, I recommend using a normalized UTF8 encoding. This
string could be...

 *  A URL.
 *  A human-readable description.
 *  A base64 hash.
 *  A passphrase.

Keeping a list of these key identifiers somewhere is generally a good
idea. It is also a good idea to develop a system for naming. The
general suggested format is `TYPE:[SUBTYPE:]DESCRIPTION[!EXTRA]`. Here
are some examples:

 *  `OpenPGP:Cert:John Doe`
 *  `OpenPGP:Auth:John Doe`
 *  `X.509:Encrypt,Sign:John Doe`
 *  `X.509:Cert:Acme CA Root`
 *  `BIP0032:Seed:John Doe`
 *  `DNSSEC:KSK:example.com!2014Q1`
 *  `DNSSEC:ZSK:example.com!2014-02-15`
 *  `SuperSecret:Delegate` (Abbreviated `Delegate/`)

For OpenPGP/SMIME/X.509, the "SUBTYPE" indicates a comma-separated
list of capabilities. The capabilities are:

 *  `Cert` - Ability to certify/sign other keys (a Certification
    Authority)
 *  `Auth` - Ability to authenticate (via SSL for example).
 *  `Sign` - Ability to sign for non-repudiation purposes.
 *  `Encrypt` - Ability to encrypt/decrypt data.

You can generate child SuperSecrets which can allow you to form a
hierarchy of key generation capability.

Nested Keys can be identified using a slash:

    Master -> SuperSecret:Delegate -> DNSSEC:ZSK:example.com!2014Q1
    M/Delegate/DNSSEC:ZSK:example.com



---------------------------




List of keys


* X.509 Encryption Certificates
  * RSA-2048
  * RSA-3072
  * RSA-4096
  * RSA-8192
  * ECDH-NIST-P-256
  * ECDH-NIST-P-348
  * ECDH-NIST-P-521
* OpenPGP Identities
  * RSA-2048
  * RSA-3072
  * RSA-4096
  * RSA-8192
  * ECDH-NIST-P-256
  * ECDH-NIST-P-348
  * ECDH-NIST-P-521
* SSH Keys
  * RSA-4096
  * RSA-8192
  * ECDSA-NIST-P-256
  * ECDSA-NIST-P-521
  * EdDSA-Ed25519
* Bitcoin Addresses
  * 100 bitcoin addresses
* SuperSecret
